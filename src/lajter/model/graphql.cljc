(ns lajter.model.graphql
  (:require
    [datascript.core :as d]
    [clojure.core.protocols :as p]
    [clojure.spec.alpha :as s]
    [clojure.set :as set]
    [lajter.model :as model]))

;; schema spec generated by spec-provider
(s/def :gql/name symbol?)
(s/def :gql/kind '#{UNION ENUM LIST OBJECT INPUT_OBJECT
                    NON_NULL SCALAR INTERFACE})

(s/def :gql/ofType (s/keys :req-un [:gql/kind]
                           :opt-un [:gql/name :gql/ofType]))
(s/def :gql/type (s/keys :req-un [:gql/kind]
                         :opt-un [:gql/name :gql/ofType]))
(s/def :gql/args (s/coll-of (s/keys :req-un [:gql/type])))

(s/def :gql/fields (s/coll-of (s/keys :req-un [:gql/name :gql/type]
                                      :opt-un [:gql/args])))
(s/def :gql/types (s/coll-of (s/keys :req-un [:gql/kind :gql/name]
                                     :opt-un [:gql/fields])))

(defn schema->model
  "Takes a graphql schema query (defined in resources/.../github-schema.gql)
  keywordized and symbolized to match the :gql/types spec. Returns a model
  matching spec :lajter.model/model.

  Metadata on the field names include:
  * When the type is required
  * Cardinality of the type
  * Whether cardinalty many fields cannot be nil (has to be empty list).
  * Input fields with names and type information."
  ([]
   (let [type->meta
         (fn self [{:keys [name kind ofType] ::keys [req?] :as node}]
           (condp = kind
             'NON_NULL (self (assoc ofType ::req? true))
             'LIST (merge {:gql.type/list?          true
                           :gql.type/required-list? req?}
                          (self ofType))
             ;; else
             (if (seq ofType)
               (throw (ex-info "Unexpected type node was 'ofType'"
                               {:node node}))
               (cond-> {:gql.type/kind            kind
                        :gql.type/name            name
                        :gql.type/required-value? req?}))))

         field->model
         (fn [{:keys [name args type]}]
           (let [input-args (mapv (fn [{:keys [name type]}]
                                    {:gql.field.input/name name
                                     :gql.field.input/type (type->meta type)})
                                  args)]
             (with-meta name {:gql.field/type   (type->meta type)
                              :gql.field/inputs input-args})))

         root-type->model
         (fn [{:keys [name kind fields possibleTypes]}]
           (let [met (hash-map
                       :gql.root/type {:gql.type/name name
                                       :gql.type/kind kind}
                       :gql.root/possible-types
                       (map #(set/rename-keys % {:name :gql.type/name
                                                 :kind :gql.type/kind})
                            possibleTypes))]
             (cond-> [(with-meta name met)]
                     (seq fields)
                     (conj (mapv field->model fields)))))]
     (mapcat root-type->model)))
  ([graphql-types]
   (into [] (schema->model) graphql-types)))

;;;;;;;;;;;;;;;;;;;;;;;;;
;; Plugin

(defn- field-input->field-node
  "Takes a field input model meta and returns a input field node
  that is to be indexed."
  [db field-node field-input]
  (let [old-id (model/q '{:find  [?e .]
                          :in    [$ ?field ?input-name]
                          :where [[?e :gql.field.input/field ?field]
                                  [?e :gql.field.input/name ?input-name]]}
                        db
                        (:db/id field-node)
                        (:gql.field.input/name field-input))]

    (->> (assoc field-input :gql.field.input/field (:db/id field-node))
         (model/merge-node db old-id))))

(def plugin:graphql-root-cleanup
  {:pipeline/fn
   (fn [_]
     (map (fn [node]
            (let [{:model.node/keys [parent meta]} node
                  {:gql.root/keys [possible-types]} meta
                  root? (not parent)]
              (cond-> node
                      (and root?
                           ;; TODO: Do something with possibleTypes
                           ;;       when kind is UNION or INTERFACE
                           (empty? possible-types))
                      (update :model.node/meta
                              dissoc
                              :gql.root/possible-types))))))})

(def plugin:graphql-input-fields
  {:pipeline/fn
   (fn [{:keys [db]}]
     (mapcat
       (fn [node]
         (let [->field-node #(field-input->field-node db node %)
               ;; Always remove field inputs as we create a dedicated node for
               ;; each of them.
               node (update node :model.node/meta dissoc :gql.field/inputs)]
           (cons node (map ->field-node (:gql.field/inputs node)))))))})

(def plugin:graphql-types
  {:db/schema
   {:gql.type/required {:db/valueType :db.type/ref}}
   :pipeline/fn
   (fn [opts]
     (map (fn [node]
            (let [met (:model.node/meta node)
                  gql-type (or (:gql.root/type met)
                               (:gql.field/type met)
                               (:gql.field.input/type node))

                  req-map (into {}
                                (filter (comp some? val))
                                (select-keys gql-type [:gql.type/required-list?
                                                       :gql.type/required-value?]))

                  {:gql.type/keys [name kind list?]} gql-type
                  new-met (cond-> met
                                  (some? name)
                                  (assoc :tag name)
                                  (contains? '#{UUID ID} name)
                                  (assoc :db/unique :db.unique/identity)
                                  (some? list?)
                                  (assoc :db/cardinality :db.cardinality/many)
                                  (seq req-map)
                                  (assoc :gql.type/required req-map)
                                  :always
                                  (dissoc :gql.root/type :gql.field/type))
                  node (-> node
                           (dissoc :gql.field.input/type)
                           (cond-> (:tag new-met)
                                   (dissoc :model.plugin.node-type/capitalized?)))]

              (assoc node :model.node/meta new-met)))))})


(def plugin:graphql
  (model/merge-plugins plugin:graphql-input-fields
                       plugin:graphql-root-cleanup
                       plugin:graphql-types))


(declare nav-type nav-entity)

(defn- nav-fields [query model-db & query-args]
  (let [navigable-field
        (fn [field]
          (with-meta
            field
            {`p/nav (fn self [_ k v]
                      (cond
                        (= :type k) (nav-type model-db v)
                        (= :field k) (nav-entity model-db (d/entity model-db v))
                        (= :name k) v
                        (= :parent k) (nav-type model-db v)))}))

        fields
        (->> (apply model/q query model-db query-args)
             (map #(zipmap [:field :type :name :parent] %))
             (map (fn [{:keys [type name parent] :as field}]
                    (with-meta [parent type name]
                               {:nav (navigable-field field)})))
             (distinct))]
    (with-meta (sort fields)
               {`p/nav (fn [_ _ v]
                         (:nav (meta v)))})))

(def nav-fields-by-type
  (partial nav-fields
           '{:find  [?field ?field-type ?sym ?parent-type]
             :in    [$ ?parent-type]
             :where [(type-fields ?parent-type ?field)
                     (node-type ?field ?field-type)
                     [?field :model.node/symbol ?sym]]}))
(def nav-fields-of-type
  (partial nav-fields
           '{:find  [?field ?field-type ?sym ?parent-type]
             :in    [$ ?field-type]
             :where [(node-type ?field ?field-type)
                     [?field :model.node/symbol ?sym]
                     (type-fields ?parent-type ?field)]}))

(defn nav-type [model-db type]
  {:type    type
   :fields  (nav-fields-by-type model-db type)
   :used-by (nav-fields-of-type model-db type)})

(defn nav-entity [model-db entity]
  (with-meta
    (into {:db/id (:db/id entity)} entity)
    {`p/nav (fn [e k v]
              (condp = k
                :model.node/meta
                (nav-entity model-db v)
                :model.node/parent
                (nav-entity model-db v)
                :tag
                (nav-type model-db v)
                :model.node/symbol
                (if (:model.plugin.root-node/root? e)
                  (nav-type model-db v)
                  (nav-fields-by-type model-db v))
                ;; else
                (if-some [e (d/entity model-db v)]
                  (nav-entity model-db e)
                  v)))}))


(defn datafy
  ([model-db]
   (let [root-types
         (model/q '{:find  [?root ?type]
                    :where [(root-node ?root ?type)]}
                  model-db)]

     {:types    (with-meta
                  (sort (map second root-types))
                  {`p/nav (fn [_ _ type]
                            (nav-type model-db type))})
      :entities (sort-by
                  :db/id
                  (into []
                        (comp (map first)
                              (map (partial d/entity model-db))
                              (map #(select-keys % [:db/id :model.node/symbol]))
                              (map (partial nav-entity model-db)))
                        root-types))})))
