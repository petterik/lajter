(ns lajter.model.graphql
  (:require
    [clojure.spec.alpha :as s]))

;; schema spec generated by spec-provider
(s/def :gql/name symbol?)
(s/def :gql/kind '#{UNION ENUM LIST OBJECT INPUT_OBJECT
                    NON_NULL SCALAR INTERFACE})

(s/def :gql/ofType (s/keys :req-un [:gql/kind]
                           :opt-un [:gql/name :gql/ofType]))
(s/def :gql/type (s/keys :req-un [:gql/kind]
                         :opt-un [:gql/name :gql/ofType]))
(s/def :gql/args (s/coll-of (s/keys :req-un [:gql/type])))

(s/def :gql/fields (s/coll-of (s/keys :req-un [:gql/name :gql/type]
                                      :opt-un [:gql/args])))
(s/def :gql/types (s/coll-of (s/keys :req-un [:gql/kind :gql/name]
                                     :opt-un [:gql/fields])))

(defn schema->model
  "Takes a graphql schema query (defined in resources/.../github-schema.gql)
  keywordized and symbolized to match the :gql/types spec. Returns a model
  matching spec :lajter.model/model.

  Metadata on the field names include:
  * When the type is required
  * Cardinality of the type
  * Whether cardinalty many fields cannot be nil (has to be empty list).
  * Input fields with names and type information."
  [graphql-types]
  (let [types graphql-types

        type->meta
        (fn self [{:keys [name kind ofType] ::keys [req?] :as node}]
          (cond
            (= kind 'NON_NULL) (self (assoc ofType ::req? true))
            (= kind 'LIST) (merge {:gql.type/list? true
                                   :many true}
                                  (when req? {:gql.type/required-list true})
                                  (self ofType))
            :else
            (merge {:tag name}
                   (when req? {:gql.type/required-type true})
                   ;; Will this ever happen?
                   (when (seq ofType)
                     (prn "WAS ofType node: " node)
                     (self ofType)))))

        args->meta
        (fn [args]
          {:gql.field/inputs
           (->> args
                (mapv (fn [{:keys [name type]}]
                        {:gql.field.input/name name
                         :gql.field.input/type (type->meta type)})))})

        field->model
        (fn self [{:keys [name args type]}]
          (with-meta name (merge (type->meta type)
                                 (when (seq args)
                                   (args->meta args)))))

        root-type->model
        (fn [{:keys [name kind fields possibleTypes]}]
          (let [m (merge
                    {:tag kind}
                    (some->> (seq possibleTypes)
                             (mapv (fn [{:keys [name kind]}]
                                     {:gql.type/name name
                                      :gql.type/kind kind}))
                             (hash-map :gql.type/possible-types)))]
            (cond-> [(with-meta name m)]
                    (seq fields)
                    (conj (mapv field->model fields)))))]
    (into []
          (mapcat root-type->model)
          types)))